// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file complex_nested_arrays.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
}  // namespace
#endif  // _WIN32

#include "complex_nested_arrays.h"
#include "complex_nested_arraysTypeObject.h"
#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

ThirdLevelElement::ThirdLevelElement()
{
    // m_x com.eprosima.idl.parser.typecode.PrimitiveTypeCode@47ef968d
    m_x = 0.0;
    // m_y com.eprosima.idl.parser.typecode.PrimitiveTypeCode@23e028a9
    m_y = 0.0;

    // Just to register all known types
    registercomplex_nested_arraysTypes();
}

ThirdLevelElement::~ThirdLevelElement()
{


}

ThirdLevelElement::ThirdLevelElement(
        const ThirdLevelElement& x)
{
    m_x = x.m_x;
    m_y = x.m_y;
}

ThirdLevelElement::ThirdLevelElement(
        ThirdLevelElement&& x) noexcept 
{
    m_x = x.m_x;
    m_y = x.m_y;
}

ThirdLevelElement& ThirdLevelElement::operator =(
        const ThirdLevelElement& x)
{

    m_x = x.m_x;
    m_y = x.m_y;

    return *this;
}

ThirdLevelElement& ThirdLevelElement::operator =(
        ThirdLevelElement&& x) noexcept
{

    m_x = x.m_x;
    m_y = x.m_y;

    return *this;
}

bool ThirdLevelElement::operator ==(
        const ThirdLevelElement& x) const
{

    return (m_x == x.m_x && m_y == x.m_y);
}

bool ThirdLevelElement::operator !=(
        const ThirdLevelElement& x) const
{
    return !(*this == x);
}

size_t ThirdLevelElement::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

size_t ThirdLevelElement::getCdrSerializedSize(
        const ThirdLevelElement& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

void ThirdLevelElement::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_x;
    scdr << m_y;

}

void ThirdLevelElement::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_x;
    dcdr >> m_y;
}

/*!
 * @brief This function sets a value in member x
 * @param _x New value for member x
 */
void ThirdLevelElement::x(
        double _x)
{
    m_x = _x;
}

/*!
 * @brief This function returns the value of member x
 * @return Value of member x
 */
double ThirdLevelElement::x() const
{
    return m_x;
}

/*!
 * @brief This function returns a reference to member x
 * @return Reference to member x
 */
double& ThirdLevelElement::x()
{
    return m_x;
}

/*!
 * @brief This function sets a value in member y
 * @param _y New value for member y
 */
void ThirdLevelElement::y(
        double _y)
{
    m_y = _y;
}

/*!
 * @brief This function returns the value of member y
 * @return Value of member y
 */
double ThirdLevelElement::y() const
{
    return m_y;
}

/*!
 * @brief This function returns a reference to member y
 * @return Reference to member y
 */
double& ThirdLevelElement::y()
{
    return m_y;
}


size_t ThirdLevelElement::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;





    return current_align;
}

bool ThirdLevelElement::isKeyDefined()
{
    return false;
}

void ThirdLevelElement::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
      
}

SecondLevelElement::SecondLevelElement()
{
    // m_an_element_alone com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@2db7a79b

    // m_a_limited_other_value com.eprosima.idl.parser.typecode.SequenceTypeCode@6950e31


    // Just to register all known types
    registercomplex_nested_arraysTypes();
}

SecondLevelElement::~SecondLevelElement()
{


}

SecondLevelElement::SecondLevelElement(
        const SecondLevelElement& x)
{
    m_an_element_alone = x.m_an_element_alone;
    m_a_limited_other_value = x.m_a_limited_other_value;
}

SecondLevelElement::SecondLevelElement(
        SecondLevelElement&& x) noexcept 
{
    m_an_element_alone = std::move(x.m_an_element_alone);
    m_a_limited_other_value = std::move(x.m_a_limited_other_value);
}

SecondLevelElement& SecondLevelElement::operator =(
        const SecondLevelElement& x)
{

    m_an_element_alone = x.m_an_element_alone;
    m_a_limited_other_value = x.m_a_limited_other_value;

    return *this;
}

SecondLevelElement& SecondLevelElement::operator =(
        SecondLevelElement&& x) noexcept
{

    m_an_element_alone = std::move(x.m_an_element_alone);
    m_a_limited_other_value = std::move(x.m_a_limited_other_value);

    return *this;
}

bool SecondLevelElement::operator ==(
        const SecondLevelElement& x) const
{

    return (m_an_element_alone == x.m_an_element_alone && m_a_limited_other_value == x.m_a_limited_other_value);
}

bool SecondLevelElement::operator !=(
        const SecondLevelElement& x) const
{
    return !(*this == x);
}

size_t SecondLevelElement::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += ThirdLevelElement::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < 1; ++a)
    {
        current_alignment += ThirdLevelElement::getMaxCdrSerializedSize(current_alignment);}


    return current_alignment - initial_alignment;
}

size_t SecondLevelElement::getCdrSerializedSize(
        const SecondLevelElement& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += ThirdLevelElement::getCdrSerializedSize(data.an_element_alone(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.a_limited_other_value().size(); ++a)
    {
        current_alignment += ThirdLevelElement::getCdrSerializedSize(data.a_limited_other_value().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void SecondLevelElement::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_an_element_alone;
    scdr << m_a_limited_other_value;

}

void SecondLevelElement::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_an_element_alone;
    dcdr >> m_a_limited_other_value;
}

/*!
 * @brief This function copies the value in member an_element_alone
 * @param _an_element_alone New value to be copied in member an_element_alone
 */
void SecondLevelElement::an_element_alone(
        const ThirdLevelElement& _an_element_alone)
{
    m_an_element_alone = _an_element_alone;
}

/*!
 * @brief This function moves the value in member an_element_alone
 * @param _an_element_alone New value to be moved in member an_element_alone
 */
void SecondLevelElement::an_element_alone(
        ThirdLevelElement&& _an_element_alone)
{
    m_an_element_alone = std::move(_an_element_alone);
}

/*!
 * @brief This function returns a constant reference to member an_element_alone
 * @return Constant reference to member an_element_alone
 */
const ThirdLevelElement& SecondLevelElement::an_element_alone() const
{
    return m_an_element_alone;
}

/*!
 * @brief This function returns a reference to member an_element_alone
 * @return Reference to member an_element_alone
 */
ThirdLevelElement& SecondLevelElement::an_element_alone()
{
    return m_an_element_alone;
}
/*!
 * @brief This function copies the value in member a_limited_other_value
 * @param _a_limited_other_value New value to be copied in member a_limited_other_value
 */
void SecondLevelElement::a_limited_other_value(
        const std::vector<ThirdLevelElement>& _a_limited_other_value)
{
    m_a_limited_other_value = _a_limited_other_value;
}

/*!
 * @brief This function moves the value in member a_limited_other_value
 * @param _a_limited_other_value New value to be moved in member a_limited_other_value
 */
void SecondLevelElement::a_limited_other_value(
        std::vector<ThirdLevelElement>&& _a_limited_other_value)
{
    m_a_limited_other_value = std::move(_a_limited_other_value);
}

/*!
 * @brief This function returns a constant reference to member a_limited_other_value
 * @return Constant reference to member a_limited_other_value
 */
const std::vector<ThirdLevelElement>& SecondLevelElement::a_limited_other_value() const
{
    return m_a_limited_other_value;
}

/*!
 * @brief This function returns a reference to member a_limited_other_value
 * @return Reference to member a_limited_other_value
 */
std::vector<ThirdLevelElement>& SecondLevelElement::a_limited_other_value()
{
    return m_a_limited_other_value;
}

size_t SecondLevelElement::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;





    return current_align;
}

bool SecondLevelElement::isKeyDefined()
{
    return false;
}

void SecondLevelElement::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
      
}

FirstLevelElement::FirstLevelElement()
{
    // m_useless_name com.eprosima.idl.parser.typecode.StringTypeCode@5891e32e
    m_useless_name ="";
    // m_sub com.eprosima.idl.parser.typecode.SequenceTypeCode@cb0ed20

    // m_an_element_alone com.eprosima.fastdds.idl.parser.typecode.StructTypeCode@2db7a79b


    // Just to register all known types
    registercomplex_nested_arraysTypes();
}

FirstLevelElement::~FirstLevelElement()
{



}

FirstLevelElement::FirstLevelElement(
        const FirstLevelElement& x)
{
    m_useless_name = x.m_useless_name;
    m_sub = x.m_sub;
    m_an_element_alone = x.m_an_element_alone;
}

FirstLevelElement::FirstLevelElement(
        FirstLevelElement&& x) noexcept 
{
    m_useless_name = std::move(x.m_useless_name);
    m_sub = std::move(x.m_sub);
    m_an_element_alone = std::move(x.m_an_element_alone);
}

FirstLevelElement& FirstLevelElement::operator =(
        const FirstLevelElement& x)
{

    m_useless_name = x.m_useless_name;
    m_sub = x.m_sub;
    m_an_element_alone = x.m_an_element_alone;

    return *this;
}

FirstLevelElement& FirstLevelElement::operator =(
        FirstLevelElement&& x) noexcept
{

    m_useless_name = std::move(x.m_useless_name);
    m_sub = std::move(x.m_sub);
    m_an_element_alone = std::move(x.m_an_element_alone);

    return *this;
}

bool FirstLevelElement::operator ==(
        const FirstLevelElement& x) const
{

    return (m_useless_name == x.m_useless_name && m_sub == x.m_sub && m_an_element_alone == x.m_an_element_alone);
}

bool FirstLevelElement::operator !=(
        const FirstLevelElement& x) const
{
    return !(*this == x);
}

size_t FirstLevelElement::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += SecondLevelElement::getMaxCdrSerializedSize(current_alignment);}

    current_alignment += ThirdLevelElement::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t FirstLevelElement::getCdrSerializedSize(
        const FirstLevelElement& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.useless_name().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.sub().size(); ++a)
    {
        current_alignment += SecondLevelElement::getCdrSerializedSize(data.sub().at(a), current_alignment);}

    current_alignment += ThirdLevelElement::getCdrSerializedSize(data.an_element_alone(), current_alignment);

    return current_alignment - initial_alignment;
}

void FirstLevelElement::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_useless_name.c_str();
    scdr << m_sub;
    scdr << m_an_element_alone;

}

void FirstLevelElement::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_useless_name;
    dcdr >> m_sub;
    dcdr >> m_an_element_alone;
}

/*!
 * @brief This function copies the value in member useless_name
 * @param _useless_name New value to be copied in member useless_name
 */
void FirstLevelElement::useless_name(
        const std::string& _useless_name)
{
    m_useless_name = _useless_name;
}

/*!
 * @brief This function moves the value in member useless_name
 * @param _useless_name New value to be moved in member useless_name
 */
void FirstLevelElement::useless_name(
        std::string&& _useless_name)
{
    m_useless_name = std::move(_useless_name);
}

/*!
 * @brief This function returns a constant reference to member useless_name
 * @return Constant reference to member useless_name
 */
const std::string& FirstLevelElement::useless_name() const
{
    return m_useless_name;
}

/*!
 * @brief This function returns a reference to member useless_name
 * @return Reference to member useless_name
 */
std::string& FirstLevelElement::useless_name()
{
    return m_useless_name;
}
/*!
 * @brief This function copies the value in member sub
 * @param _sub New value to be copied in member sub
 */
void FirstLevelElement::sub(
        const std::vector<SecondLevelElement>& _sub)
{
    m_sub = _sub;
}

/*!
 * @brief This function moves the value in member sub
 * @param _sub New value to be moved in member sub
 */
void FirstLevelElement::sub(
        std::vector<SecondLevelElement>&& _sub)
{
    m_sub = std::move(_sub);
}

/*!
 * @brief This function returns a constant reference to member sub
 * @return Constant reference to member sub
 */
const std::vector<SecondLevelElement>& FirstLevelElement::sub() const
{
    return m_sub;
}

/*!
 * @brief This function returns a reference to member sub
 * @return Reference to member sub
 */
std::vector<SecondLevelElement>& FirstLevelElement::sub()
{
    return m_sub;
}
/*!
 * @brief This function copies the value in member an_element_alone
 * @param _an_element_alone New value to be copied in member an_element_alone
 */
void FirstLevelElement::an_element_alone(
        const ThirdLevelElement& _an_element_alone)
{
    m_an_element_alone = _an_element_alone;
}

/*!
 * @brief This function moves the value in member an_element_alone
 * @param _an_element_alone New value to be moved in member an_element_alone
 */
void FirstLevelElement::an_element_alone(
        ThirdLevelElement&& _an_element_alone)
{
    m_an_element_alone = std::move(_an_element_alone);
}

/*!
 * @brief This function returns a constant reference to member an_element_alone
 * @return Constant reference to member an_element_alone
 */
const ThirdLevelElement& FirstLevelElement::an_element_alone() const
{
    return m_an_element_alone;
}

/*!
 * @brief This function returns a reference to member an_element_alone
 * @return Reference to member an_element_alone
 */
ThirdLevelElement& FirstLevelElement::an_element_alone()
{
    return m_an_element_alone;
}

size_t FirstLevelElement::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;






    return current_align;
}

bool FirstLevelElement::isKeyDefined()
{
    return false;
}

void FirstLevelElement::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
       
}

complex_nested_arrays::complex_nested_arrays()
{
    // m_array_of_elements com.eprosima.idl.parser.typecode.ArrayTypeCode@1fc2b765


    // Just to register all known types
    registercomplex_nested_arraysTypes();
}

complex_nested_arrays::~complex_nested_arrays()
{
}

complex_nested_arrays::complex_nested_arrays(
        const complex_nested_arrays& x)
{
    m_array_of_elements = x.m_array_of_elements;
}

complex_nested_arrays::complex_nested_arrays(
        complex_nested_arrays&& x) noexcept 
{
    m_array_of_elements = std::move(x.m_array_of_elements);
}

complex_nested_arrays& complex_nested_arrays::operator =(
        const complex_nested_arrays& x)
{

    m_array_of_elements = x.m_array_of_elements;

    return *this;
}

complex_nested_arrays& complex_nested_arrays::operator =(
        complex_nested_arrays&& x) noexcept
{

    m_array_of_elements = std::move(x.m_array_of_elements);

    return *this;
}

bool complex_nested_arrays::operator ==(
        const complex_nested_arrays& x) const
{

    return (m_array_of_elements == x.m_array_of_elements);
}

bool complex_nested_arrays::operator !=(
        const complex_nested_arrays& x) const
{
    return !(*this == x);
}

size_t complex_nested_arrays::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;



    for(size_t a = 0; a < (3); ++a)
    {
        current_alignment += FirstLevelElement::getMaxCdrSerializedSize(current_alignment);}
    return current_alignment - initial_alignment;
}

size_t complex_nested_arrays::getCdrSerializedSize(
        const complex_nested_arrays& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;



    for(size_t a = 0; a < data.array_of_elements().size(); ++a)
    {
            current_alignment += FirstLevelElement::getCdrSerializedSize(data.array_of_elements().at(a), current_alignment);
    }
    return current_alignment - initial_alignment;
}

void complex_nested_arrays::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_array_of_elements;


}

void complex_nested_arrays::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_array_of_elements;

}

/*!
 * @brief This function copies the value in member array_of_elements
 * @param _array_of_elements New value to be copied in member array_of_elements
 */
void complex_nested_arrays::array_of_elements(
        const std::array<FirstLevelElement, 3>& _array_of_elements)
{
    m_array_of_elements = _array_of_elements;
}

/*!
 * @brief This function moves the value in member array_of_elements
 * @param _array_of_elements New value to be moved in member array_of_elements
 */
void complex_nested_arrays::array_of_elements(
        std::array<FirstLevelElement, 3>&& _array_of_elements)
{
    m_array_of_elements = std::move(_array_of_elements);
}

/*!
 * @brief This function returns a constant reference to member array_of_elements
 * @return Constant reference to member array_of_elements
 */
const std::array<FirstLevelElement, 3>& complex_nested_arrays::array_of_elements() const
{
    return m_array_of_elements;
}

/*!
 * @brief This function returns a reference to member array_of_elements
 * @return Reference to member array_of_elements
 */
std::array<FirstLevelElement, 3>& complex_nested_arrays::array_of_elements()
{
    return m_array_of_elements;
}

size_t complex_nested_arrays::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;



    return current_align;
}

bool complex_nested_arrays::isKeyDefined()
{
    return false;
}

void complex_nested_arrays::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
     
}
